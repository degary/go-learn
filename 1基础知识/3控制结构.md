​	现代计算机存储结构无论“普林斯顿结构”，还是“哈佛结构”，程序指令都是线性地存放在存储器上。程序执行从本质上来说就是两种模式： **顺序和跳转**

- 顺序就是按照程序指令在存储器上的存放顺序逐条执行

- 跳转就是遇到跳转指令就跳转到某处继续线性执行

  ​	Go是一门高级语言，其源程序虽然经过了高度的抽象并封装了很多语法糖，但还是跳不出这个模式

  ​	顺序在Go里面体现在从main函数开始逐条向下执行，就像我们的程序源代码顺序一样；跳转在Go里面体现为多个语法糖，包括goto语句和函数调用、分支(if,switch,select)、循环（for）等。跳转分为两种：一种是无条件跳转，比如函数调用和goto语句；一种是有条件跳转，比如分支和循环

  ​	顺序语句很简单，就是我们天然写程序的从前往后的顺序

  **备注**

  Go的源代码的顺序并不一定是编译后最终可执行程序的指令顺序，这里边设计语言的运行时和包的加载过程。

# 1.if语句

**特点**

- if后面的条件判断字句不需要小括号包起来
- **{** 必须放在行尾，和if或 if else 放在一行
- if后面可以带一个简单的初始化语句，并以分号分割，该简单语句声明的变量的作用域是整个if语句块，包括后面的else if 和else分支。
- Go语言没有跳进运算符(a>b?a:b), 这也符合Go的设计哲学，只提供一种方法做事情。
- if分支语句遇到return后直接返回

**简单实例**

```go
if x <= y {
	return y
} else {
	return x
}
```

**一个完整的if else语句示例：**

```go
if x := f(); x < y { //初始化语句中的声明变量x
	retuen x
} else if x > z { //x在else if里一样可以被访问到
	return z
}else {
	return y
}
```

**最佳实践**

- 尽量减少条件语句的复杂度，如果条件语句太多、太复杂，则建议放到函数里面封装起来
- 尽量减少if语句的嵌套层次，通过重构让代码变得扁平，便于阅读

如下：

```go
if err,file := os.Open("xxxx");err == nil {
	defer file.Close()
	// do somethine
} else {
	return nil,err
}
```

改写后的代码

```go
err, file := os.Open("xxxx")
if err != nil {
	return nil,err
}
defer file.Close()
```

# 2.switch语句

switch语句会根据传入的参数检测并执行符合条件的分支。

**switch的语法特点如下:**

- switch 和 if 语句一样，switch后面可以带一个可选择的简单的初始化语句
- switch后面的表达式也可以是可选的，如果没有表达式，则case子句是一个布尔表达式，而不是一个值，此时就相当于多重if else语句。
- switch条件表达式的值不像C语言那样必须限制为整数，可以是任意支持相等比较运算的类型变量。
- 通过`fallthough`语句来强制执行下一个case子句（不再判断下一个case子句的条件是否满足）
- switch支持default语句，当所有的case分支都不符合时，执行default语句，并且default语句可以放到任意位置，并不影响switch的判断逻辑
- switch和.(type)结合可以进行类型的查询